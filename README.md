# KPO4
Работа написана на основе Java 20 и Spring 3.1.0. база данных PostgreSQL. Для тестирования база данных чиститься после кажого запуска. (в папке КПО4 - микросервис авторизации, а в orders - микросервис управления заказами)
## Тестировние
Для тестирование используется Postman, его коллекция предоставлена в проекте (с уже предоставленными телами).
### POST http://localhost:8080/api/v1/auth/register
Отвечает за регистрацию, необходимо передать в body raw JSON формата:
* Имя
* Фамилия
* Почта
* Пароль

Также присутсвует проверка если такая почта уже существует (вернеться ошибка если это так)
Пример можно увидеть в коллекции:
```json
{
"firstname": "alibou",
"lastname": "alibou",
"email": "ghost5016628@mail.ru",
"password": "555"
}
```
После успешной авторизации пользователь будет занесен в базу данных
### POST http://localhost:8080/api/v1/auth/authenticate
Отвечает за авторизацию, необходимо передать в body JSON формата:
* Почта
* Пароль

Если пароль верный, то вернеться токен пользователя, иначе выдасться ошибка
Пример можно видеть в коллекции:
<br>Некорректный пароль(Если воспользоваться регистрацией из примера):
```json
{
    "email": "ghost5016628@mail.ru",
    "password": "5555"
}
```
<br>Корректный пароль(Если воспользоваться регистрацией из примера):
```json
{
    "email": "ghost5016628@mail.ru",
    "password": "555"
}
```
### GET http://localhost:8080/api/v1/demo-controller
Данный запрос нужет только для проверки работы системы аутентификации. Чтобы запрос сработал, необходимо в разделе аутентификации указать чистый токен (его надо взять из результата корректной авторизации). Если токен правильный, то вернеться сообщение: "Hello from secured endpoint".
В противном случае выбросится ошибка.
### GET http://localhost:8080/api/v1/user/get
Отвечает за получение пользователя по его токену, необходимо передать в body JSON формата:
* Токен

Пример можно увидеть в коллекции:
```json
{
    "token": "eyJhbGciOiJIUzI1NiJ9.eyJzdWIiOiJnaG9zdDUwMTY2MjhAbWFpbC5ydSIsImlhdCI6MTY4Njg1NjQ2NCwiZXhwIjoxNjg2ODU3OTA0fQ.RImMfwTX0s8WaA5WIk390Yjf7GcGBWYhymws12puJjs"
}
```
<br> Помимо тела необходима авторизация, так же как и в demo-controller (изначально доступ к этой функции был только у роли ADMIN, но чтобы вам было проще тестировать был предоставлен доступ и обычным USER)
Если токены валидны и в теле и в авторизации, то выведется информация о пользователе (пароль будет в зашифрованном состоянии). Иначе выведется ошибка.
### POST http://localhost:8081/dishes
Данный запрос создает новое блюдо в меню. Поле name обязано быть уникальным для разных блюд, price > 0, quantity >= 0. В случае не выполнения перечисленных ограничений, будет выброшено исключение. Обязательна авторизация через токен, полученный с микросервиса авторизации.

Пример тела можно увидеть в коллекции:
```json
{
    "name": "Сельдь под шубой",
    "description": "Знаменитое блюдо русской кухни",
    "price": 560,
    "quantity": 10
}
```
```json
{
    "name": "Крутон",
    "description": "Как гренка, но гренка не может стоить 3000, а крутон - может",
    "price": 3000,
    "quantity": 12
}
```
### GET http://localhost:8081/dishes
Данный запрос выводит пользователю меню со всеми блюдами, доступное количество которых > 0. Единственное требование - авторизация с помощью токена, полученного с сервиса авторизации.
### POST http://localhost:8081/orders
Запрос Создает новый заказ. В случае отсутвие таких полей: status, created_at, updated_at, программа автоматически их заполнит. Поле user_id заполняется автоматически, в случае корретной авторизации через токен из микросервиса авторизации (это обязательное условие).

Пример тела запроса можно увидеть в коллекции:
```json
{
    "status": "в ожидании",
    "special_requests": "Рыбку обязательно свежую!",
    "orderDishes": [{
        "dish": 1,
        "quantity": 2,
        "price": 1120
    }]
}
```
### GET http://localhost:8081/orders/1
Запрос для получения информации о пользователе. Как и все запросы микросервиса управления заказами необходима авторизация через токен с микросервиса авторизации.
### PUT http://localhost:8081/orders
Запрос обновляет статус на готов у случайно выбранного заказа, находящихся в ожидании обработки.
<br>P.S. это только основные запросы во второй микросервис, остальные также выполнены с учетом требований, поскольку они ситаутивны, то и выносить их отделно не было необходимости.
